{{!Stats section}}
<div class="mb-12">
  <div class="flex justify-between items-center mb-6">
    <h2 class="text-2xl font-semibold">Resource Utilization</h2>
    <div class="flex items-center space-x-2">
      <label for="partition-select" class="text-sm">Partition:</label>
      <select id="partition-select" class="border rounded p-2 w-[180px]">
        {{#each partitions}}
          <option value="{{this.id}}">{{this.name}}</option>
        {{/each}}
      </select>
    </div>
  </div>

  <div id="partition-badge" class="mb-4 hidden">
    <span class="bg-gray-200 text-gray-700 rounded-full px-3 py-1 text-sm inline-flex items-center">
      Showing stats for: <span id="selected-partition-name" class="font-semibold ml-1"></span>
    </span>
  </div>

  <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
    <div class="bg-white rounded-lg shadow border flex flex-col">
      <div class="pb-2 border-b p-4">
        <h3 class="text-lg font-medium">CPU Utilization</h3>
      </div>
      <div class="flex-1 flex items-center justify-center p-4">
        <div id="sunburst-chart-cpu" class="h-full mx-auto"></div>
      </div>
    </div>

    <div class="bg-white rounded-lg shadow border flex flex-col">
      <div class="pb-2 border-b p-4">
        <h3 class="text-lg font-medium">Memory Utilization</h3>
      </div>
      <div class="flex-1 flex items-center justify-center p-4">
        <div id="sunburst-chart-mem" class="h-full mx-auto"></div>
      </div>
    </div>

    <div class="bg-white rounded-lg shadow border flex flex-col">
      <div class="pb-2 border-b p-4">
        <h3 class="text-lg font-medium">GPU Utilization</h3>
      </div>
      <div class="flex-1 flex items-center justify-center p-4">
        <div id="sunburst-chart-gpu" class="h-full mx-auto"></div>
      </div>
    </div>
  </div>
</div>
<!-- Filter Form and rest of the existing code -->

<h2 class="text-center text-gray-800 mb-6 text-2xl">Slurm Job Queue</h2>

<!-- Filter Form -->
<div class="mb-4">
  <form id="filter-form" class="flex space-x-2">
    <select id="filter-field" class="border rounded p-2">
      <option value="jobid">JobID</option>
      <option value="partition">Partition</option>
      <option value="name">Name</option>
      <option value="user">User</option>
      <option value="account">Account</option>
      <option value="state">State</option>
      <option value="statereason">State Reason</option>
    </select>
    <div class="relative flex-1">
      <input type="text" id="filter-value" placeholder="Filter value or 'key1:value1 key2:value2' for multiple" class="w-full border rounded p-2" autocomplete="off" />
      <div id="autocomplete-dropdown" class="absolute left-0 right-0 top-full mt-1 bg-white border border-gray-300 rounded shadow-lg hidden z-50 max-h-60 overflow-y-auto"></div>
    </div>
    <button type="submit" id="add-filter-btn" class="bg-blue-500 text-white rounded p-2">Add Filter</button>
    <button type="button" id="save-filter-btn" class="bg-green-500 text-white rounded p-2">Update</button>
  </form>
</div>

<!-- Active Filters Badges -->
<div id="active-filters" class="mb-4 flex flex-wrap gap-2"></div>

<!-- Jobs Table Container -->
{{> jobsTable}}



<script>
  // ----- D3 js Sunburts chart logic -----
  // Helper function to draw a sunburst chart in a given container.
  function drawSunburstChart(data, containerId, titleText, totalSuffix) {
    document.getElementById(containerId).innerHTML = '';
    const width = 500;
    const radius = width / 2;
    
    // Prepare a semantic color scale for all charts
    let color;
    if (containerId === "sunburst-chart-gpu") {
      // For GPU chart - use semantic colors based on usage state
      color = d => {
        // Special case for zero GPUs - use allocated color to indicate "no available GPUs"
        if (d.data.name === "No GPUs") {
          return "#e63946"; // Red color for "no available GPUs"
        }
        // Special case for errors - use a distinct error color
        if (d.data.name === "Error") {
          return "#8b5cf6"; // Purple color for errors
        }
        // First level: Used vs Available
        if (d.depth === 1) {
          return d.data.name === "Used" ? "#e63946" : "#2a9d8f"; // Red for used, Green for available
        } 
        // Second level: Different GPU types get different shades based on parent
        else if (d.depth === 2) {
          const parentName = d.parent.data.name;
          if (parentName === "Used") {
            // Different shades of red/orange for used GPUs
            const usedColors = ["#e63946", "#f94144", "#f3722c", "#f8961e", "#f9844a"];
            return usedColors[d.parent.children.indexOf(d) % usedColors.length];
          } else {
            // Different shades of green/blue for available GPUs
            const availableColors = ["#2a9d8f", "#52b788", "#76c893", "#99d98c", "#b5e48c"];
            return availableColors[d.parent.children.indexOf(d) % availableColors.length];
          }
        }
        return "#888888"; // Fallback gray color
      };
    } else {
      // For CPU and Memory charts - use consistent semantic colors
      color = d => {
        if (d.depth === 1) {
          // Use consistent semantic colors for resource states
          switch (d.data.name) {
            case "Allocated": return "#e63946"; // Red for allocated/used
            case "Idle": return "#2a9d8f"; // Green for idle/available  
            case "Down": return "#6c757d"; // Gray for down/unavailable
            case "Other": return "#ffc107"; // Yellow for other/mixed states
            default: return "#888888"; // Fallback gray
          }
        }
        return "#888888"; // Fallback for deeper levels
      };
    }
    
    // Partition layout: convert data into a hierarchy with computed angles.
    const partition = d => d3.partition()
      .size([2 * Math.PI, radius])
      (d3.hierarchy(data)
        .sum(d => d.value)
        .sort((a, b) => b.value - a.value));

    const arc = d3.arc()
      .startAngle(d => d.x0)
      .endAngle(d => d.x1)
      .padAngle(d => Math.min((d.x1 - d.x0) / 2, 0.005))
      .padRadius(radius / 2)
      .innerRadius(d => d.y0)
      .outerRadius(d => d.y1 - 1);

    const root = partition(data);

    // Create the SVG container.
    const svg = d3.create("svg")
      .attr("viewBox", [-radius, -radius, width, width]).style("height", "400px")
      .style("font", "10px sans-serif");

    // For GPU charts, use totalGPUs if available, otherwise use the sum of values
    let total = root.value;
    if (containerId === "sunburst-chart-gpu" && data.totalGPUs !== undefined) {
      total = data.totalGPUs;
    }
    
    // Add central label.
    svg.append("text")
      .attr("text-anchor", "middle")
      .attr("dy", "0.35em")
      .style("font-size", "16px")
      .style("font-weight", "bold")
      .text(titleText + " Total: " + Math.round(total) + (totalSuffix ? " " + totalSuffix : ""));

    // Draw arcs.
    svg.append("g")
      .attr("fill-opacity", 0.6)
      .selectAll("path")
      .data(root.descendants().filter(d => d.depth))
      .join("path")
      .attr("fill", d => {
          // All charts now use semantic color mapping
          return color(d);
      })
      .attr("d", arc)
      .append("title")
      .text(d => `${d.ancestors().map(d => d.data.name).reverse().join("/")}\n${d3.format(",d")(d.value)}`);

    // Add labels to arcs if space permits.
    svg.append("g")
      .attr("pointer-events", "none")
      .attr("text-anchor", "middle")
      .attr("font-size", 10)
      .attr("font-family", "sans-serif")
      .selectAll("text")
      .data(root.descendants().filter(d => d.depth && ((d.y0 + d.y1) / 2 * (d.x1 - d.x0)) > 10))
      .join("text")
      .attr("transform", d => {
          const x = (d.x0 + d.x1) / 2 * 180 / Math.PI;
          const y = (d.y0 + d.y1) / 2;
          return `rotate(${x - 90}) translate(${y},0) rotate(${x < 180 ? 0 : 180})`;
      })
      .attr("dy", "0.35em")
      .text(d => d.data.name);

    // Append the SVG into the target container.
    document.getElementById(containerId).appendChild(svg.node());
  }

  // Data for CPU sunburst chart (provided by your CPU stats function).
  var cpuData = {
    name: "CPU Utilization",
    children: [
      { name: "Allocated", value: {{cpuStats.allocated}} },
      { name: "Idle", value: {{cpuStats.idle}} },
      { name: "Other", value: {{cpuStats.other}} }
    ]
  };

  // Data for Memory sunburst chart (provided by your memory stats function).
  // Note: Your memStats object includes "allocated", "idle", "down", "other", and "total"
  var memData = {
    name: "Memory Utilization",
    children: [
      { name: "Allocated", value: {{memStats.allocated}} },
      { name: "Idle", value: {{memStats.idle}} },
      { name: "Down", value: {{memStats.down}} },
      { name: "Other", value: {{memStats.other}} }
    ]
  };


  // Render both charts.
  drawSunburstChart(cpuData, "sunburst-chart-cpu", "CPU");
  drawSunburstChart(memData, "sunburst-chart-mem", "Memory", "GB");
  drawSunburstChart({{{json gpuStats}}}, "sunburst-chart-gpu", "GPU");

  function updateChartsForPartition(partition) {
    const baseUrl = "{{passengerBaseUri}}".replace(/\/$/, '');
    const partitionBadge = document.getElementById('partition-badge');
    const selectedPartitionName = document.getElementById('selected-partition-name');
    
    // Show/hide partition badge
    if (partition === 'all') {
      partitionBadge.classList.add('hidden');
    } else {
      // Find the partition name from the select element
      const partitionSelect = document.getElementById('partition-select');
      const selectedOption = partitionSelect.options[partitionSelect.selectedIndex];
      selectedPartitionName.textContent = selectedOption.text;
      partitionBadge.classList.remove('hidden');
    }
    
    // Fetch stats for the selected partition
    fetch(`${baseUrl}/api/stats?partition=${partition}`)
      .then(response => response.json())
      .then(data => {
        if (data.success) {
          // Create updated chart data
          const newCpuData = {
            name: "CPU Utilization",
            children: [
              { name: "Allocated", value: data.cpuStats.allocated },
              { name: "Idle", value: data.cpuStats.idle },
              { name: "Other", value: data.cpuStats.other }
            ]
          };
          
          const newMemData = {
            name: "Memory Utilization",
            children: [
              { name: "Allocated", value: data.memStats.allocated },
              { name: "Idle", value: data.memStats.idle },
              { name: "Down", value: data.memStats.down },
              { name: "Other", value: data.memStats.other }
            ]
          };
          
          // Redraw charts with new data
          drawSunburstChart(newCpuData, "sunburst-chart-cpu", "CPU");
          drawSunburstChart(newMemData, "sunburst-chart-mem", "Memory", "GB");
          drawSunburstChart(data.gpuStats, "sunburst-chart-gpu", "GPU");
        } else {
          console.error("Error fetching stats:", data.error);
        }
      })
      .catch(err => {
        console.error("Error updating stats:", err);
      });
  }

  // Listen for partition selection changes
  document.getElementById('partition-select').addEventListener('change', function() {
    updateChartsForPartition(this.value);
  });


  // ----- jobs filtering logic -----
  // Get current query parameters as an object
  function getQueryParams() {
    const params = {};
    const searchParams = new URLSearchParams(window.location.search);
    for (const [key, value] of searchParams.entries()) {
      // Convert page and pageSize to numbers
      if (key === 'page' || key === 'pageSize') {
        params[key] = parseInt(value);
      } else {
        params[key] = value;
      }
    }
    return params;
  }

  // Update the URL query parameters without reloading the page
  function updateURL(params) {
    const url = new URL(window.location);
    url.search = new URLSearchParams(params).toString();
    window.history.pushState({}, '', url);
  }

  // Render the active filters as badges
  function renderFilters(params) {
    const container = document.getElementById('active-filters');
    container.innerHTML = '';

    //avoid these
    const reservedParams = ['page', 'pageSize']

    for (const key in params) {
      if(reservedParams.includes(key)) continue;

      const badge = document.createElement('span');
      badge.className = "bg-gray-300 text-gray-700 rounded-full px-3 py-1 text-sm flex items-center";
      badge.innerHTML = `${key}: ${params[key]} <button data-key="${key}" class="ml-2 text-red-500 font-bold">x</button>`;
      container.appendChild(badge);
    }
  }

  function fetchJobs(params) {
    const queryString = new URLSearchParams(params).toString();
    console.log("Fetching jobs table with query string: ", queryString);
    const baseUrl = "{{passengerBaseUri}}".replace(/\/$/, '');
    const container = document.getElementById('jobs-table');

    // Fetch the rendered HTML from partials endpoint and then replace the html in browser heree
    fetch(`${baseUrl}/partials/jobs-table?${queryString}`)
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.text(); // expected HTML here
      })
      .then(html => {
        container.outerHTML = html; // replace the container itself

        // re-attach event listeners
        const newContainer = document.getElementById('jobs-table');
        if (newContainer) {
          attachClientSidePagination(newContainer);
          attachPageSizeSelector(newContainer);
        }
      })
      .catch(err => {
        console.error('Error fetching jobs table:', err);
        container.innerHTML = `<p class="text-red-500">Error fetching job data: ${err.message}</p>`;
      });
  }

  // Quick filter parsing functions
  function parseQuickFilters(filterString) {
    const filters = {};
    const validFilterTypes = ['jobid', 'partition', 'name', 'user', 'account', 'state', 'statereason'];
    
    // Split by spaces but handle quoted values
    const pairs = [];
    let current = '';
    let inQuotes = false;
    
    for (let i = 0; i < filterString.length; i++) {
      const char = filterString[i];
      
      if (char === '"' || char === "'") {
        inQuotes = !inQuotes;
        current += char;
      } else if (char === ' ' && !inQuotes) {
        if (current.trim()) {
          pairs.push(current.trim());
          current = '';
        }
      } else {
        current += char;
      }
    }
    
    if (current.trim()) {
      pairs.push(current.trim());
    }
    
    // Parse each key:value pair
    for (const pair of pairs) {
      const colonIndex = pair.indexOf(':');
      if (colonIndex > 0 && colonIndex < pair.length - 1) {
        const key = pair.substring(0, colonIndex).trim().toLowerCase();
        let value = pair.substring(colonIndex + 1).trim();
        
        // Remove quotes if present
        if ((value.startsWith('"') && value.endsWith('"')) || 
            (value.startsWith("'") && value.endsWith("'"))) {
          value = value.slice(1, -1);
        }
        
        if (validFilterTypes.includes(key) && value) {
          filters[key] = value;
        }
      }
    }
    
    return filters;
  }
  
  function isQuickFilterFormat(filterString) {
        // Check if the string contains at least one key:value pair
    const quickFilterRegex = /\b(jobid|partition|name|user|account|state|statereason)\s*:\s*\S+/i;
    return quickFilterRegex.test(filterString);
  }
  
  function updateAddButton(filterValue) {
    const addButton = document.getElementById('add-filter-btn');
    const fieldSelect = document.getElementById('filter-field');
    
    if (isQuickFilterFormat(filterValue)) {
      addButton.textContent = 'Add Filters';
      addButton.className = 'bg-purple-500 hover:bg-purple-600 text-white rounded p-2 transition-colors';
      fieldSelect.disabled = true;
      fieldSelect.style.opacity = '0.5';
    } else {
      addButton.textContent = 'Add Filter';
      addButton.className = 'bg-blue-500 hover:bg-blue-600 text-white rounded p-2 transition-colors';
      fieldSelect.disabled = false;
      fieldSelect.style.opacity = '1';
    }
  }

  // Initialize active filters from the URL
  let activeFilters = getQueryParams();
  renderFilters(activeFilters);

  // Attach listeners to static elements on the page
  document.getElementById('filter-form').addEventListener('submit', function (e) {
    e.preventDefault();
    const fieldSelect = document.getElementById('filter-field');
    const filterField = fieldSelect.value;
    const filterValue = document.getElementById('filter-value').value.trim();
    
    if (filterValue) {
      if (isQuickFilterFormat(filterValue)) {
        // Handle multiple filters
        const quickFilters = parseQuickFilters(filterValue);
        const filterCount = Object.keys(quickFilters).length;
        
        if (filterCount > 0) {
          // Add all parsed filters to activeFilters
          Object.assign(activeFilters, quickFilters);
          
          // Show feedback message
          const filterValueInput = document.getElementById('filter-value');
          const originalPlaceholder = filterValueInput.placeholder;
          filterValueInput.placeholder = `Added ${filterCount} filter${filterCount > 1 ? 's' : ''}!`;
          filterValueInput.style.backgroundColor = '#f0f9ff';
          
          setTimeout(() => {
            filterValueInput.placeholder = originalPlaceholder;
            filterValueInput.style.backgroundColor = '';
          }, 2000);
        } else {
          // Show error for invalid format
          const filterValueInput = document.getElementById('filter-value');
          const originalPlaceholder = filterValueInput.placeholder;
          filterValueInput.placeholder = 'Invalid format! Use: key1:value1 key2:value2';
          filterValueInput.style.backgroundColor = '#fef2f2';
          
          setTimeout(() => {
            filterValueInput.placeholder = originalPlaceholder;
            filterValueInput.style.backgroundColor = '';
          }, 3000);
          return;
        }
      } else {
        // Handle single filter (original behavior)
        activeFilters[filterField] = filterValue;
      }
      
      // Reset to page 1 for new filters
      activeFilters.page = 1;
      renderFilters(activeFilters);
      updateURL(activeFilters);
    }
    document.getElementById('filter-value').value = '';
    updateAddButton(''); // Reset button state
  });

  document.getElementById('active-filters').addEventListener('click', function (e) {
    if (e.target.tagName.toLowerCase() === 'button') {
      const key = e.target.getAttribute('data-key');
      delete activeFilters[key];
      // Reset to page 1 when a filter is removed
      activeFilters.page = 1;
      renderFilters(activeFilters);
      updateURL(activeFilters);
      fetchJobs(activeFilters); // Fetch immediately on removal
    }
  });

  document.getElementById('save-filter-btn').addEventListener('click', function () {
    console.log("Clicked save, fetching with filters:", activeFilters);
    fetchJobs(activeFilters);
  });

  // Add input event listener to detect quick filter format
  document.getElementById('filter-value').addEventListener('input', function (e) {
    updateAddButton(e.target.value);
  });
  
  function attachClientSidePagination(container) {
    // Change the server-rendered links to client-side fetches
    container.querySelectorAll('a.pagination-link').forEach(link => {
      link.addEventListener('click', function(e) {
        e.preventDefault(); // Prevent full page reload
        const url = new URL(this.href);
        const page = url.searchParams.get('page');
        if (page) {
          activeFilters.page = parseInt(page);
          updateURL(activeFilters);
          fetchJobs(activeFilters);
        }
      });
    });
  }

  function attachPageSizeSelector(container) {
    const pageSizeSelector = container.querySelector('#page-size-select');
    if (pageSizeSelector) {
      pageSizeSelector.addEventListener('change', function() {
        const newPageSize = parseInt(this.value);
        activeFilters.pageSize = newPageSize;
        activeFilters.page = 1; // Reset to page 1
        updateURL(activeFilters);
        fetchJobs(activeFilters);
      });
    }
  }
  
  // ----- Autocomplete Logic -----
  const availablePartitions = {{{json partitions}}};
  const availableStates = {{{json jobStates}}};
  const availableStateReasons = {{{json jobStateReasons}}};

  const filterInput = document.getElementById('filter-value');
  const autocompleteDropdown = document.getElementById('autocomplete-dropdown');
  let currentFocus = -1;

  filterInput.addEventListener('input', function(e) {
    const val = this.value;
    const cursorPosition = this.selectionStart;
    
    // Find the word at the cursor
    const textBeforeCursor = val.substring(0, cursorPosition);
    const lastSpaceIndex = textBeforeCursor.lastIndexOf(' ');
    const currentWordStart = lastSpaceIndex + 1;
    const currentWord = val.substring(currentWordStart, cursorPosition); // Only up to cursor
    
    let matches = [];
    let prefix = '';

    // Check if we are typing a partition filter
    if (currentWord.toLowerCase().startsWith('partition:')) {
      prefix = 'partition:';
      const filterVal = currentWord.substring(10).toLowerCase(); // remove "partition:"
      
      // Filter partitions
      matches = availablePartitions.filter(p => 
        p.id !== 'all' && 
        p.id.toLowerCase().includes(filterVal)
      );
    } else if (currentWord.toLowerCase().startsWith('state:')) {
      prefix = 'state:';
      const filterVal = currentWord.substring(6).toLowerCase(); // remove "state:"
      
      // Filter states
      matches = availableStates.filter(s => 
        s.id.toLowerCase().includes(filterVal) || 
        s.name.toLowerCase().includes(filterVal)
      );
    } else if (currentWord.toLowerCase().startsWith('statereason:')) {
      prefix = 'statereason:';
      const filterVal = currentWord.substring(12).toLowerCase(); // remove "statereason:"
      
      // Filter state reasons
      matches = availableStateReasons.filter(r => 
        r.toLowerCase().includes(filterVal)
      ).map(r => ({ id: r, name: r }));
    } else {
      // check if the currently selected dropdown field supports autocomplete
      const selectedField = document.getElementById('filter-field').value;
      
      if (selectedField === 'partition') {
        matches = availablePartitions.filter(p => 
          p.id !== 'all' && 
          p.id.toLowerCase().includes(currentWord.toLowerCase())
        );
      } else if (selectedField === 'state') {
        matches = availableStates.filter(s => 
          s.id.toLowerCase().includes(currentWord.toLowerCase()) || 
          s.name.toLowerCase().includes(currentWord.toLowerCase())
        );
      } else if (selectedField === 'statereason') {
        matches = availableStateReasons.filter(r => 
          r.toLowerCase().includes(currentWord.toLowerCase())
        ).map(r => ({ id: r, name: r }));
      }
    }
      
    if (matches.length > 0) {
      showAutocomplete(matches, currentWordStart, prefix);
    } else {
      closeAutocomplete();
    }
  });

  function showAutocomplete(matches, wordStartIndex, prefix) {
    autocompleteDropdown.innerHTML = '';
    autocompleteDropdown.classList.remove('hidden');
    currentFocus = -1;

    matches.forEach(match => {
      const div = document.createElement('div');
      div.className = 'p-2 hover:bg-gray-100 cursor-pointer border-b last:border-b-0';
      div.innerHTML = `<span class="font-medium">${match.name}</span> <span class="text-gray-500 text-xs ml-1">(${match.id})</span>`;
      div.addEventListener('click', function() {
        insertValue(match.id, wordStartIndex, prefix);
      });
      autocompleteDropdown.appendChild(div);
    });
  }

  function insertValue(value, wordStartIndex, prefix) {
    const originalText = filterInput.value;
    const textBeforeWord = originalText.substring(0, wordStartIndex);
    
    // Find where the current word ends (space or end of string)
    let wordEndIndex = originalText.indexOf(' ', wordStartIndex);
    if (wordEndIndex === -1) wordEndIndex = originalText.length;
    
    const textAfterWord = originalText.substring(wordEndIndex);
    
    const newText = textBeforeWord + prefix + value + textAfterWord;
    filterInput.value = newText;
    
    closeAutocomplete();
    filterInput.focus();
    
    // Move cursor to end of inserted value
    const newCursorPos = textBeforeWord.length + prefix.length + value.length; 
    filterInput.setSelectionRange(newCursorPos, newCursorPos);
    
    // Trigger input event to update buttons
    filterInput.dispatchEvent(new Event('input'));
  }

  function closeAutocomplete() {
    autocompleteDropdown.innerHTML = '';
    autocompleteDropdown.classList.add('hidden');
    currentFocus = -1;
  }

  filterInput.addEventListener('keydown', function(e) {
    const items = autocompleteDropdown.getElementsByTagName('div');
    if (autocompleteDropdown.classList.contains('hidden')) return;

    if (e.key === 'ArrowDown') {
      currentFocus++;
      addActive(items);
      e.preventDefault();
    } else if (e.key === 'ArrowUp') {
      currentFocus--;
      addActive(items);
      e.preventDefault();
    } else if (e.key === 'Enter') {
      if (currentFocus > -1) {
        e.preventDefault();
        if (items[currentFocus]) items[currentFocus].click();
      }
    } else if (e.key === 'Escape') {
      closeAutocomplete();
      e.preventDefault();
    }
  });

  function addActive(items) {
    if (!items) return;
    removeActive(items);
    if (currentFocus >= items.length) currentFocus = 0;
    if (currentFocus < 0) currentFocus = items.length - 1;
    items[currentFocus].classList.add('bg-blue-100');
    items[currentFocus].scrollIntoView({ block: 'nearest' });
  }

  function removeActive(items) {
    for (let i = 0; i < items.length; i++) {
      items[i].classList.remove('bg-blue-100');
    }
  }

  document.addEventListener('click', function(e) {
    if (e.target !== filterInput && e.target !== autocompleteDropdown && !autocompleteDropdown.contains(e.target)) {
      closeAutocomplete();
    }
  });

  // Initial attachment of listeners for the server-rendered table
  const initialJobsTable = document.getElementById('jobs-table');
  if(initialJobsTable) {
    attachClientSidePagination(initialJobsTable);
    attachPageSizeSelector(initialJobsTable);
  }


function handleExpandClick(e) {
  const button = e.target.closest('.expand-btn');
  if (!button) return;

  const mainRow = button.closest('.job-row');
  const jobState = mainRow.dataset.jobState;
  const jobId = button.dataset.jobId;
  const detailsRow = document.getElementById(`details-row-${jobId}`);
  const icon = button.querySelector('svg');
  const isExpanded = button.getAttribute('aria-expanded') === 'true';
  

  //expand
  button.setAttribute('aria-expanded', button.getAttribute('aria-expanded') !== 'true');
  detailsRow.classList.toggle('hidden');
  icon.classList.toggle('rotate-90');

  //if job state is completed the fetch and show seff data
  if (jobState === 'COMPLETED' && !isExpanded) {
    const reportContainer = detailsRow.querySelector('.seff-report-container');
    if (reportContainer && !reportContainer.dataset.loaded) {
      // Mark it as "loading has started" immediately
      reportContainer.dataset.loaded = 'true'; 
      fetchAndDisplaySeffReport(jobId, reportContainer);
    }
  }

  //if job state is pending then fetch and show pending reason
  if (jobState === 'PENDING' && !isExpanded) {
    const pendingContainer = detailsRow.querySelector('.pending-reason-container');
    if (pendingContainer && !pendingContainer.dataset.loaded) {
      pendingContainer.dataset.loaded = 'true';
      fetchAndDisplayPendingReason(jobId, pendingContainer);
    }
  }
}

function fetchAndDisplayPendingReason(jobId, container) {
    container.innerHTML = `
        <hr class="my-4 border-slate-200">
        <div class="p-4 flex items-center justify-center text-sm text-slate-500">
            <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-slate-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            Analyzing Pending Reason...
        </div>
    `;

    const baseUrl = "{{passengerBaseUri}}".replace(/\/$/, '');
    fetch(`${baseUrl}/api/jobs/${jobId}/pending-reason`)
        .then(res => res.json())
        .then(response => {
            if (response.success) {
                renderPendingReason(response.data, container);
            } else {
                throw new Error(response.error || 'Unknown error from server');
            }
        })
        .catch(err => {
            console.error('Failed to fetch pending reason:', err);
            container.innerHTML = `
                <hr class="my-4 border-slate-200">
                <div class="p-4 text-red-600">
                    Error analyzing pending reason.
                </div>
            `;
        });
}

function renderPendingReason(data, container) {
    let html = '<hr class="my-4 border-slate-200"><div class="p-6 bg-white rounded-lg shadow-sm border border-slate-200 mx-6 mb-6">';
    
    if (data.type === 'Resources') {
        html += `
            <div class="flex items-center mb-4">
                <div class="bg-yellow-100 text-yellow-800 p-2 rounded-full mr-3">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                </div>
                <div>
                    <h3 class="text-lg font-semibold text-slate-800">Pending Reason: Resources</h3>
                    <p class="text-sm text-slate-600">Scope: ${data.scope}</p>
                </div>
            </div>
        `;

        if (data.summary) {
            html += `
                <div class="grid grid-cols-3 gap-4 mb-6 text-center">
                    <div class="bg-slate-50 p-3 rounded border border-slate-200">
                        <div class="text-2xl font-bold text-slate-700">${data.summary.totalNodesAnalyzed}</div>
                        <div class="text-xs text-slate-500 uppercase tracking-wide">Total Nodes</div>
                    </div>
                    <div class="bg-red-50 p-3 rounded border border-red-100">
                        <div class="text-2xl font-bold text-red-600">${data.summary.blockedNodes}</div>
                        <div class="text-xs text-red-500 uppercase tracking-wide">Blocked Nodes</div>
                    </div>
                    <div class="bg-green-50 p-3 rounded border border-green-100">
                        <div class="text-2xl font-bold text-green-600">${data.summary.freeNodes}</div>
                        <div class="text-xs text-green-500 uppercase tracking-wide">Free Nodes</div>
                    </div>
                </div>
            `;
        }

        if (data.details && data.details.length > 0) {
            html += '<h4 class="font-medium text-slate-700 mb-3">Node Analysis</h4>';
            html += '<div class="space-y-3 max-h-96 overflow-y-auto pr-2">';
            
            data.details.forEach(node => {
                if (node.isBlocked) {
                    html += `
                        <div class="border border-red-200 rounded-md p-3 bg-red-50">
                            <div class="flex justify-between items-start mb-2">
                                <span class="font-mono font-semibold text-red-700">${node.name}</span>
                                <span class="text-xs bg-red-200 text-red-800 px-2 py-0.5 rounded">Blocked</span>
                            </div>
                            <div class="space-y-1">
                                ${node.bottlenecks.map(b => `
                                    <div class="text-sm flex justify-between items-center">
                                        <span class="font-medium text-slate-700">${b.resource}</span>
                                        <span class="text-slate-600">
                                            Req: <span class="font-mono">${b.required}</span> / 
                                            Avail: <span class="font-mono">${b.available}</span>
                                        </span>
                                    </div>
                                    <div class="w-full bg-red-200 rounded-full h-1.5">
                                        <div class="bg-red-500 h-1.5 rounded-full" style="width: ${Math.min((b.available / b.required) * 100, 100)}%"></div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    `;
                } else {
                     html += `
                        <div class="border border-green-200 rounded-md p-3 bg-green-50 opacity-75">
                            <div class="flex justify-between items-center">
                                <span class="font-mono font-semibold text-green-700">${node.name}</span>
                                <span class="text-xs bg-green-200 text-green-800 px-2 py-0.5 rounded">Available</span>
                            </div>
                        </div>
                    `;
                }
            });
            html += '</div>';
        }

    } else if (data.type === 'Status') {
        html += `
            <div class="flex items-center text-green-600">
                <svg class="w-6 h-6 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>
                <span class="font-semibold">${data.message}</span>
            </div>
        `;
    } else if (data.type === 'Other') {
        html += `
            <div class="flex items-center text-blue-600 mb-2">
                <svg class="w-6 h-6 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                <div>
                    <h3 class="font-semibold">Pending Reason</h3>
                    <p>${data.message}</p>
                </div>
            </div>
            <div class="text-sm text-slate-500 italic ml-8">
                Detailed analysis for this pending reason is coming soon.
            </div>
        `;
    } else {
        html += `
            <div class="text-red-600">
                <p class="font-semibold">Error</p>
                <p>${data.message || 'Unknown error'}</p>
            </div>
        `;
    }

    html += '</div>';
    container.innerHTML = html;
}

function fetchAndDisplaySeffReport(jobId, container) {
    // Show a loading state
    container.innerHTML = `
        <hr class="my-4 border-slate-200">
        <div class="p-4 flex items-center justify-center text-sm text-slate-500">
            <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-slate-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            Loading Efficiency Report...
        </div>
    `;

    // fetch partial from the server endpoint
    const baseUrl = "{{passengerBaseUri}}".replace(/\/$/, '');
    fetch(`${baseUrl}/partials/seff-report/${jobId}`)
        .then(response => {
            // The server will send a 200 OK for a success partial
            // and a 404 Not Found for an error partial. We just need the text.
            return response.text();
        })
        .then(html => {
            // 3. Inject the final HTML (which could be the report or the error message).
            container.innerHTML = html;
        })
        .catch(err => {
            console.error('Failed to fetch seff report:', err);
            container.innerHTML = `
                <hr class="my-4 border-slate-200">
                <div class="p-4 text-red-600">
                    A network error occurred while fetching the report. Please check your connection.
                </div>
            `;
        });
}

document.addEventListener('click', handleExpandClick);
</script>